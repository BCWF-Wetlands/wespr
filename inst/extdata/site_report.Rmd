---
title: "WESP site report"
output: word_document
params:
  calibration_scores_eco: calibration_scores_eco
  calibration_scores_summary: calibration_scores_summary,
  classed_df: classed_df
  output_dir: output_dir
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(wespr)
library(dplyr)
library(ggplot2)
library(sf)
library(stringr)

#testing lines 
#calibration_scores_eco = calibration_scores_eco
##calibration_scores_summary = calibration_scores_summary
#classed_df = classed_df
#output_dir = output_dir
# end testing line 

```


```{r cars, echo = FALSE}
#summary(cars)
ecop <- unique(calibration_scores_summary$ecoprovince)
sname <- unique(classed_df$site)

# add map to show where in the province

```

**Report generated on :** `r Sys.Date()`

**Site Name :** `r sname`

## 1. Background

This report provides a summary of ecosystem function and benefit scores for a given site using the Wetland Ecosystem Services Protocol for British Columbia (WESP-BC). WESP collects information about a given wetland through field and desktop questions and generates a numeric score from 1 - 10 for 33 ecosystem metrics. These are broadly grouped into 18 ecosystem functions and 15 benefits. 

Due to the wide geographic diversity across BC, wetlands are grouped by Ecoprovince, with 8 provinces across BC. These include: Georgia Depression (GD), Southern Interior (SI), Central Interior (CI), Southern Interior Mountains (SIM), Sub-Boreal Interior (SBI), Boreal and Taiga Plains (BTP), Northern Boreal Mountains (NBM), and Coast and Mountains (CM)).

For each Ecoprovince, a reference data set is used to ensure and new wetlands can be compared to an appropriate baseline scores. This also allows comparison of scores broadly across Ecoprovinces. To generate the baseline scores per ecoprovince, approximately 100 wetlands are surveyed and function and benefit numeric scores are calculated according to the WESP-BC process. For each function and benefit we then use the distribution of numeric (using the 100 reference sites) and define numeric thresholds to split the data into three classes: low (L), medium (M) or high (H) values based on the jenks breaks method. This statistical method looks for natural breaks and clusters within the reference data set to identify threshold values for each class. 

We can now assign a new site to a category (L/M/H) based on where the values of the new site score relative to the baseline scores derived from the 100 reference sites within that ecoporvince. This allows sites from difference ecoprovinces to be compared across the Province. 

More information can about the project can be found [here](https://bcwfwatershedteam.ca/wetland-ecosystem-services-protocol/). 

<br>


## 2. Site Description 

This site(`r sname`) is located in the `r ecop` Ecoprovince. 

```{r generate map, echo = FALSE}
if (ecop == "GD"){
  ecop = "GED"
}
  
ecoi <- ecoprovince_sp |>
  dplyr::filter(ECOPROVINCE_CODE == ecop)

map1 <- ggplot() +
  geom_sf(data = ecoprovince_sp$geometry, fill = "lightgrey") +
  geom_sf(data = ecoi, fill = "lightblue") +
  labs(title = paste0("Ecoprovince : ", stringr::str_to_title(unique(ecoi$ECOPROVINCE_NAME))))+
  theme_void()
```

```{r plot map, echo = FALSE, fig.width=3.5, fig.height=3.25}
map1

```

```{r, echo = FALSE}

# generate the background information for Calibration thresholds
# Calculate the numbers per group or by plot

cal_no <- calibration_scores_eco

wcols <- names(calibration_scores_eco)
## remove the site column
wcols <- wcols[!wcols %in% c("site", "wetland_id", "ecoprovince")]
wcols <- unique(sub("^([^_]*_[^_]*).*", "\\1", wcols))

# loop through the data and get the min and max values of the raw scores

outsum <- purrr::map(wcols, function(x) {
  # get the columns for each service
  # x <- wcols[1]

  tw <- calibration_scores_eco |>
    dplyr::select(dplyr::starts_with(x)) |>
    dplyr::select(-dplyr::ends_with("_norm"))
  names(tw) <- c("jenks", "raw")

  tww <- tw |>
    # dplyr::group_by(jenks) |>
    # dplyr::summarise(n = n(),
    #                  min = min(raw),
    #                  max = max(raw)) |>
    dplyr::mutate(
      service = x,
      service_name = unique(sub("^([^_]*).*", "\\1", service)),
      service_type = unique(sub("^[^_]*_", "", service))
    )
  tww
}) |> dplyr::bind_rows()

outsum <- outsum |>
  dplyr::mutate(jenks = ordered(jenks, levels = c("H", "M", "L"))) |>
  mutate(service_full_name = case_when(
    service_name == "AM" ~ "Amphibian Habitat (AM)",
    service_name == "APP" ~ "Aquatic Primary Productivity (APP)",
    service_name == "CP" ~ "Carbon Preservation (CP)",
    service_name == "CRI" ~ "Cultural Recreational Importance (CRI)",
    service_name == "FH" ~ "Fish Habitat (FH)",
    service_name == "FR" ~ "Fire Resistance (FR)",
    service_name == "KMH" ~ "Keystone Mammal Habitat (KMH)",
    service_name == "NR" ~ "Nitrate Removal and Retention (NR)",
    service_name == "OE" ~ "Organic Matter Export (OE)",
    service_name == "PD" ~ "Native Plant Diversity (PD)",
    service_name == "POL" ~ "Pollinator Habitat (POL)",
    service_name == "PR" ~ "Phosphorus Retention (PR)",
    service_name == "RSB" ~ "Raptor and Wetland Songbird Habitat (RSB)",
    service_name == "SENS" ~ "Wetland Sensitivity (SENS)",
    service_name == "SFTS" ~ "Stream Flow and Temperature Support (SFTS)",
    service_name == "SR" ~ "Sediment Retention and stabilization (SR)",
    service_name == "STR" ~ "Wetland Stressors (STR)",
    service_name == "WB" ~ "Waterbird Habitat (WB)",
    service_name == "WS" ~ "Water Storage and Delay (WS)"
  ))

# Calculate the numbers per group or by plot
cal_no <- calibration_scores_eco

# grouped scores
outsum_f <- outsum |>
  dplyr::filter(service_type == "f")


```

<br>


### 2.1 Ecosystem Raw Scores

We can review the scores based on raw scores or those classified into low medium and high grouping


```{r, echo = FALSE}
# generate raw values plots based on themes 

# functions 
ffraw <- classed_df |> 
  mutate(service_name = indicator) |> 
  mutate(service_full_name = case_when(
    service_name == "AM" ~ "Amphibian Habitat (AM)",
    service_name == "APP" ~ "Aquatic Primary Productivity (APP)",
    service_name == "CP" ~ "Carbon Preservation (CP)",
    service_name == "CRI" ~ "Cultural Recreational Importance (CRI)",
    service_name == "FH" ~ "Fish Habitat (FH)",
    service_name == "FR" ~ "Fire Resistance (FR)",
    service_name == "KMH" ~ "Keystone Mammal Habitat (KMH)",
    service_name == "NR" ~ "Nitrate Removal and Retention (NR)",
    service_name == "OE" ~ "Organic Matter Export (OE)",
    service_name == "PD" ~ "Native Plant Diversity (PD)",
    service_name == "POL" ~ "Pollinator Habitat (POL)",
    service_name == "PR" ~ "Phosphorus Retention (PR)",
    service_name == "RSB" ~ "Raptor and Wetland Songbird Habitat (RSB)",
    service_name == "SENS" ~ "Wetland Sensitivity (SENS)",
    service_name == "SFTS" ~ "Stream Flow and Temperature Support (SFTS)",
    service_name == "SR" ~ "Sediment Retention and stabilization (SR)",
    service_name == "STR" ~ "Wetland Stressors (STR)",
    service_name == "WB" ~ "Waterbird Habitat (WB)",
    service_name == "WS" ~ "Water Storage and Delay (WS)"
  ))

ffraw <- ffraw |> 
  select(service_type, value, service_full_name) |> 
  mutate(service_type_full = case_when(
    service_type == "f" ~ "function",
    service_type == "b" ~ "benefit"
  ))

raw_plot <- ggplot(ffraw, aes(x = service_type_full, y = service_full_name)) +
  geom_tile(aes(fill = value)) +
  geom_text(aes(label = round(value, 1))) +
  #scale_fill_continuous("blue")
  theme(palette.colour.continuous = c("#DEEBF7", "#9ECAE1", "#3182BD"))+
  labs(
    x = "",
    y = "Ecosystem Function"
  )+
  theme(legend.position="none")


```


```{r raw_plots, echo = FALSE, width = 10}
raw_plot

```


### 2.2 Ecosystem Function Scores


```{r, echo = FALSE}
# # generate raw values plots based on themes 
# 
# # functions 
# 
# ff <- classed_df |> 
#   mutate(service_name = indicator) |> 
#   mutate(service_full_name = case_when(
#     service_name == "AM" ~ "Amphibian Habitat (AM)",
#     service_name == "APP" ~ "Aquatic Primary Productivity (APP)",
#     service_name == "CP" ~ "Carbon Preservation (CP)",
#     service_name == "CRI" ~ "Cultural Recreational Importance (CRI)",
#     service_name == "FH" ~ "Fish Habitat (FH)",
#     service_name == "FR" ~ "Fire Resistance (FR)",
#     service_name == "KMH" ~ "Keystone Mammal Habitat (KMH)",
#     service_name == "NR" ~ "Nitrate Removal and Retention (NR)",
#     service_name == "OE" ~ "Organic Matter Export (OE)",
#     service_name == "PD" ~ "Native Plant Diversity (PD)",
#     service_name == "POL" ~ "Pollinator Habitat (POL)",
#     service_name == "PR" ~ "Phosphorus Retention (PR)",
#     service_name == "RSB" ~ "Raptor and Wetland Songbird Habitat (RSB)",
#     service_name == "SENS" ~ "Wetland Sensitivity (SENS)",
#     service_name == "SFTS" ~ "Stream Flow and Temperature Support (SFTS)",
#     service_name == "SR" ~ "Sediment Retention and stabilization (SR)",
#     service_name == "STR" ~ "Wetland Stressors (STR)",
#     service_name == "WB" ~ "Waterbird Habitat (WB)",
#     service_name == "WS" ~ "Water Storage and Delay (WS)"
#   )) |> 
#   select( service_type, value, service_name, service_full_name) |> 
#   mutate(service_type_full = case_when(
#     service_type == "f" ~ "function",
#     service_type == "b" ~ "benefit"
#   ))
# 
# ggplot(ff, aes(x = service_type_full, y = service_full_name)) +
#   geom_tile(aes(fill = value)) +
#   geom_text(aes(label = round(value, 1))) +
#   #scale_fill_continuous("blue")
#   theme(palette.colour.continuous = c("#DEEBF7", "#9ECAE1", "#3182BD"))+
#   labs(
#     x = "Ecosystem Score",
#     y = "Ecosystem Function"
#   )

```



```{r overall plots, echo=FALSE, fig.width=8, fig.height=7}
tt <- calibration_scores_summary |>
  group_by(.data$service) |>
  select(-n) |>
  tidyr::pivot_wider(names_from = jenks, values_from = c(min, max)) |>
  dplyr::mutate(
    H = 10.1 - min_H,
    M = min_H - min_M,
    L = min_M
  )

ttt <- tt |>
  tidyr::pivot_longer(
    cols = c(H, M, L, -min_H, -min_L, -min_M, -max_H, -max_L, -max_M),
    names_to = "catergory",
    values_to = "threshold"
  ) |>
  dplyr::select(-c(min_H, min_L, min_M, max_H, max_L, max_M))

ttt <- ttt |>
  dplyr::mutate(class = ordered(catergory, levels = c("H", "M", "L"))) |>
  mutate(service_full_name = case_when(
    service_name == "AM" ~ "Amphibian Habitat (AM)",
    service_name == "APP" ~ "Aquatic Primary Productivity (APP)",
    service_name == "CP" ~ "Carbon Preservation (CP)",
    service_name == "CRI" ~ "Cultural Recreational Importance (CRI)",
    service_name == "FH" ~ "Fish Habitat (FH)",
    service_name == "FR" ~ "Fire Resistance (FR)",
    service_name == "KMH" ~ "Keystone Mammal Habitat (KMH)",
    service_name == "NR" ~ "Nitrate Removal and Retention (NR)",
    service_name == "OE" ~ "Organic Matter Export (OE)",
    service_name == "PD" ~ "Native Plant Diversity (PD)",
    service_name == "POL" ~ "Pollinator Habitat (POL)",
    service_name == "PR" ~ "Phosphorus Retention (PR)",
    service_name == "RSB" ~ "Raptor and Wetland Songbird Habitat (RSB)",
    service_name == "SENS" ~ "Wetland Sensitivity (SENS)",
    service_name == "SFTS" ~ "Stream Flow and Temperature Support (SFTS)",
    service_name == "SR" ~ "Sediment Retention and stabilization (SR)",
    service_name == "STR" ~ "Wetland Stressors (STR)",
    service_name == "WB" ~ "Waterbird Habitat (WB)",
    service_name == "WS" ~ "Water Storage and Delay (WS)"
  ))

# match format for site data
classed_df <- classed_df |>
  dplyr::mutate(
    service = paste0(indicator, "_", service_type),
    service_name = indicator,
    threshold = value
  ) |>
  mutate(service_full_name = case_when(
    service_name == "AM" ~ "Amphibian Habitat (AM)",
    service_name == "APP" ~ "Aquatic Primary Productivity (APP)",
    service_name == "CP" ~ "Carbon Preservation (CP)",
    service_name == "CRI" ~ "Cultural Recreational Importance (CRI)",
    service_name == "FH" ~ "Fish Habitat (FH)",
    service_name == "FR" ~ "Fire Resistance (FR)",
    service_name == "KMH" ~ "Keystone Mammal Habitat (KMH)",
    service_name == "NR" ~ "Nitrate Removal and Retention (NR)",
    service_name == "OE" ~ "Organic Matter Export (OE)",
    service_name == "PD" ~ "Native Plant Diversity (PD)",
    service_name == "POL" ~ "Pollinator Habitat (POL)",
    service_name == "PR" ~ "Phosphorus Retention (PR)",
    service_name == "RSB" ~ "Raptor and Wetland Songbird Habitat (RSB)",
    service_name == "SENS" ~ "Wetland Sensitivity (SENS)",
    service_name == "SFTS" ~ "Stream Flow and Temperature Support (SFTS)",
    service_name == "SR" ~ "Sediment Retention and stabilization (SR)",
    service_name == "STR" ~ "Wetland Stressors (STR)",
    service_name == "WB" ~ "Waterbird Habitat (WB)",
    service_name == "WS" ~ "Water Storage and Delay (WS)"
  ))


# summary of the ranks overall
all_ranks_f <- classed_df |>
  filter(service_type == "f") |>
  group_by(calibration_scores_summary) |>
  summarise(n = n())

# functions
ft <- ttt |>
  dplyr::filter(service_type == "f")

fclass <- classed_df |>
  dplyr::filter(service_type == "f") |>
  filter(!is.na(value)) |>
  left_join(outsum)


fn_plot <- ggplot(ft, aes(x = threshold, y = service_full_name)) +
  geom_bar(aes(fill = class), stat = "identity", position = "stack") +
  scale_fill_viridis_d() +
  # geom_text(data= fclass,aes(x= max,y=service_full_name,label=n), color = "darkgrey",vjust=0) +
  geom_point(data = fclass, aes(x = threshold, y = service_full_name, size = 1.25), colour = "darkgrey") +
  labs(
    x = "Ecosystem Score",
    y = "Ecosystem Function"
  ) +
  scale_size(guide = 'none')+
  theme_minimal()

```

This site ecosystem function scores included `r all_ranks_f |> filter(calibration_scores_summary == "H") |> pull(n)` High ranked functions, `r all_ranks_f |> filter(calibration_scores_summary == "M") |> pull(n)` Medium ranked functions and `r all_ranks_f |> filter(calibration_scores_summary == "L") |> pull(n)` Low ranked functions. 


The plot below shows where `r sname` scores relative to the baseline values for the `r ecop` Ecoprovince. The grey dot indicated the site scores, while the yellow, aqua and purple bars show the threshold values for Low, Medium, High ranked sites within the Ecoprovince.  

```{r, echo = FALSE, fig.width=8, fig.height=6}
 fn_plot
```
<br>

#### High Ranked Functions

```{r, echo = FALSE}
fclass <-  classed_df|> 
   dplyr::filter(service_type == "f") |> 
   filter(!is.na(value)) |> 
   select(service_full_name, calibration_scores_summary,service_name )

```

Ecosystems for the high ranked functions include: `r fclass |> filter(calibration_scores_summary == "H") |> pull(service_full_name) |> paste(collapse = ", ")`. 
<br>

#### Low Ranked Functions

Ecosystems for the low ranked functions include: `r fclass |> filter(calibration_scores_summary == "L") |> pull(service_full_name) |> paste(collapse = ", ")`. 


<br>

### 2.3 Ecosystem Benefit Scores 

```{r, echo = FALSE, fig.width=8, fig.height=6}
 # Benefit
 bt <- ttt |> 
   dplyr::filter(service_type == "b") 
 
 bclass <-  classed_df|> 
   dplyr::filter(service_type == "b")|> 
   filter(!is.na(value))
 
 
bn_plot <-  ggplot(bt , aes(x = threshold,y = service_full_name  )) +
    geom_bar(aes(fill = class), stat = "identity", position = "stack")+
    scale_fill_viridis_d()+ 
   #  geom_text(data= dfTab,aes(x=x,y=Freq,label=lab),vjust=0) +
    geom_point(data =  bclass, aes( x = threshold, y = service_full_name, size = 1.25 ), colour = "darkgrey")+
   labs(
        x = "Ecosystem Score",
        y = "Ecosystem Benefit") +
   scale_size(guide = 'none')+
   theme_minimal()

 #summary of the ranks overall 
 all_ranks_b <- bclass |> 
  group_by(calibration_scores_summary) |>
  summarise(n = n())
   
```

This site ecosystem benefit scores included `r all_ranks_b |> filter(calibration_scores_summary == "H") |> pull(n)` High ranked benefits, `r all_ranks_b |> filter(calibration_scores_summary == "M") |> pull(n)` Medium ranked benefits and `r all_ranks_b |> filter(calibration_scores_summary == "L") |> pull(n)` Low ranked benefits 

```{r echo = FALSE, fig.width=8, fig.height=6}
 bn_plot 
```

<br>

#### High Ranked Benefits

```{r, echo = FALSE}
bclass <-  classed_df|> 
   dplyr::filter(service_type == "b") |> 
   filter(!is.na(value)) |> 
   select(service_full_name, calibration_scores_summary,service_name)

```

Ecosystems for the high ranked benefits include: `r bclass |> filter(calibration_scores_summary == "H") |> pull(service_full_name) |> paste(collapse = ", ")`. 
<br>

#### Low Ranked Benefits
Ecosystems for the high ranked benefits include: `r bclass |> filter(calibration_scores_summary == "L") |> pull(service_full_name) |> paste(collapse = ", ")`.


```{r, eval = FALSE, echo = FALSE}

# Still to add

### review all indicators? or review which ones are producing high results? 

### Individual sensitivity analysis? I think this will take too long? 

```

<br>

<br>

## Appendix: Ecoprovince Reference Scores 

```{r, echo = FALSE}
# generate the background information for Calibration thresholds 
#Calculate the numbers per group or by plot 
cal_no <- calibration_scores_eco

 wcols <- names(calibration_scores_eco)
  ## remove the site column
  wcols <- wcols[!wcols %in% c("site", "wetland_id","ecoprovince")]
  wcols <- unique(sub("^([^_]*_[^_]*).*", "\\1", wcols))

  # loop through the data and get the min and max values of the raw scores

   outsum <- purrr::map(wcols, function(x) {
     # get the columns for each service
    #x <- wcols[1]

     tw <- calibration_scores_eco |>
       dplyr::select(dplyr::starts_with(x)) |>
       dplyr::select(-dplyr::ends_with("_norm"))
     names(tw) <- c("jenks", "raw" )

     tww <- tw |>
       #dplyr::group_by(jenks) |>
       #dplyr::summarise(n = n(),
      #                  min = min(raw),
      #                  max = max(raw)) |>
      dplyr::mutate(service = x,
              service_name = unique(sub("^([^_]*).*", "\\1", service)),
              service_type = unique(sub("^[^_]*_", "", service)))
     tww

   }) |>  dplyr::bind_rows()
   
   
   outsum <- outsum |> 
   dplyr::mutate(jenks = ordered(jenks, levels = c("H", "M", "L"))) |> 
    mutate(service_full_name = case_when(
       service_name == "AM" ~ "Amphibian Habitat (AM)",
    service_name == "APP" ~ "Aquatic Primary Productivity (APP)",
    service_name == "CP" ~ "Carbon Preservation (CP)",
    service_name == "CRI" ~ "Cultural Recreational Importance (CRI)",
    service_name == "FH" ~ "Fish Habitat (FH)",
    service_name == "FR" ~ "Fire Resistance (FR)",
    service_name == "KMH" ~ "Keystone Mammal Habitat (KMH)",
    service_name == "NR" ~ "Nitrate Removal and Retention (NR)",
    service_name == "OE" ~ "Organic Matter Export (OE)",
    service_name == "PD" ~ "Native Plant Diversity (PD)",
    service_name == "POL" ~ "Pollinator Habitat (POL)",
    service_name == "PR" ~ "Phosphorus Retention (PR)",
    service_name == "RSB" ~ "Raptor and Wetland Songbird Habitat (RSB)",
    service_name == "SENS" ~ "Wetland Sensitivity (SENS)",
    service_name == "SFTS" ~ "Stream Flow and Temperature Support (SFTS)",
    service_name == "SR" ~ "Sediment Retention and stabilization (SR)",
    service_name == "STR" ~ "Wetland Stressors (STR)",
    service_name == "WB" ~ "Waterbird Habitat (WB)",
    service_name == "WS" ~ "Water Storage and Delay (WS)"))

#Calculate the numbers per group or by plot 
cal_no <- calibration_scores_eco

# grouped scores 
outsum_f <- outsum |> 
  dplyr::filter(service_type == "f") 

outsum_b <- outsum |> 
  dplyr::filter(service_type == "b") 

```

The `r ecop` Ecoprovince has been calibrated using `r length(cal_no)` sites. 

To calculate the threshold values for the low, medium and high groupings, we firstly calculated raw numeric values for the `r length(cal_no)` reference sites. For each ecosystem function or benefit we then apply a min-max normalization, to scale all the values between 0 - 1. 

```{r, echo = FALSE, eval = FALSE}
# example of min-max normalisation function

 min_max_norm <- function(x) {
    (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
 }

# set of example values 
x <- c(0,1,5,10)

# output of values after min-max scaling is applied. 
min_max_norm(x)

```

We then apply the jenks breaks algorithm to the range of scaled values. This identified natural breaks in the distribution of the data. 

The following plots show the distribution of raw scores from the calibration sites and how the classification to low, medium or high are defined. 


## Ecosystem Functions 

```{r, add calibration map, echo = FALSE, fig.width=14, fig.height=10}
ggplot(outsum_f, aes(x = raw , fill = jenks)) +
   geom_histogram( alpha=0.6, position = 'identity')+
    scale_fill_viridis_d()+ 
    geom_density(data=outsum_f, aes(x=raw, group=jenks, fill=jenks), adjust=1.5, alpha=.4) +
    facet_wrap(~service_full_name, scales = "free_y") +
   labs(title = "Calibration Sites threshold values for Ecosystem Functions",
        x = "Function Score",
        y = "Number of sites") +
  guides(col= guide_legend(title= "Class"))+
  theme_minimal()
```

## Ecosystem Benefits

```{r, add calibration benefit map, echo = FALSE, fig.width=14, fig.height=10}
ggplot(outsum_b, aes(x = raw , fill = jenks)) +
   geom_histogram( alpha=0.6, position = 'identity')+
    scale_fill_viridis_d()+ 
    geom_density(data=outsum_b, aes(x=raw, group=jenks, fill=jenks), adjust=1.5, alpha=.4) +
    facet_wrap(~service_full_name, scales = "free_y") +
   labs(title = "Calibration Sites threshold values for Ecosystem Benefits",
        x = "Benefit Score",
        y = "Number of sites") +
  guides(col= guide_legend(title= "Class"))+
   theme_minimal()
```
